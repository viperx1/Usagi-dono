# Crash Log Functionality

## Overview

The crash log functionality provides automatic crash detection and logging for the Usagi-dono application. When the application crashes due to an unhandled exception or signal, a detailed crash log is generated and saved to disk.

## Features

- **Automatic Crash Detection**: Catches various types of crashes including:
  - Segmentation faults (SIGSEGV)
  - Abort signals (SIGABRT)
  - Floating point exceptions (SIGFPE)
  - Illegal instructions (SIGILL)
  - Bus errors (SIGBUS) on Unix-like systems
  - Trace/breakpoint traps (SIGTRAP) on Unix-like systems
  - Windows-specific exceptions (access violations, divide by zero, etc.)

- **Detailed Crash Information**: Each crash log includes:
  - Crash reason (signal or exception type)
  - Timestamp (when the crash occurred, in local time)
  - Application name and version
  - Qt version
  - Operating system details (name, kernel type/version, product type/version)
  - Hardware information:
    - CPU architecture
    - Number of CPU cores
    - Total and available physical memory (in MB)
  - Display information (screen resolution and DPI for each monitor)
  - Stack trace with function names and offsets (on all platforms)

- **Persistent Logging**: Application logs are also written to a persistent file (`usagi.log`) for debugging purposes.

## Crash Log Location

When a crash occurs, the crash handler writes logs in two locations:

1. **Immediate crash log**: A simple `crash.log` file is written to the current working directory using only async-signal-safe functions. This ensures the crash can be logged even in the most severe failure scenarios.

2. **Detailed application logs**: Regular application logs (non-crash) are saved to `usagi.log` in the application's data directory:
   - **Windows**: `%APPDATA%/Usagi-dono/usagi.log`
   - **Linux**: `~/.local/share/Usagi-dono/usagi.log`
   - **macOS**: `~/Library/Application Support/Usagi-dono/usagi.log`

## Implementation Details

The crash handler is implemented in:
- `usagi/src/crashlog.h` - Header file with interface
- `usagi/src/crashlog.cpp` - Implementation with signal/exception handlers
- `usagi/src/main.cpp` - Integration into application startup

The handler is installed at application startup before the main window is shown, ensuring that crashes are caught throughout the application lifetime.

### Debug Symbols

To ensure that crash logs show function names from the Usagi codebase (not just Qt library functions), debug symbols must be enabled during compilation. The CMakeLists.txt files are configured to automatically include debug symbols:

- **MSVC**: Uses `/Zi` flag for debug info in PDB and `/DEBUG:FULL` linker flag for complete symbol information. The `/DEBUG:FULL` flag ensures all symbolic debug information is included in the PDB file (not just public symbols), which is essential for crash logs to show Usagi application function names alongside Qt library functions.
- **GCC/Clang**: Uses `-g` flag for debug symbols and `-gdwarf-4` for DWARF v4 format
- **MinGW on Windows**: Uses `-g` compiler flag and `-g` linker flag to prevent stripping

These flags are included in both Debug and Release builds, ensuring that crash logs always contain meaningful function names and offsets. Without debug symbols, the crash log would only show memory addresses and Qt library function names, making it difficult to identify the source of crashes in the Usagi application code. 

**Important for MSVC builds**: The PDB (Program Database) file generated by `/Zi` must be present alongside the executable for crash logs to show Usagi function names. If the PDB file is missing or not in the symbol search path, only Qt library functions (which have their symbols embedded) will appear in crash logs.

On Windows with MinGW/GCC, the `-gdwarf-4` flag ensures debug symbols are generated in DWARF version 4 format, which is more compatible with Windows dbghelp.dll for symbol resolution. The linker flag `-g` prevents the linker from stripping debug symbols from the final executable.

On Windows, the crash handler is configured to use `SymSetOptions` with `SYMOPT_UNDNAME`, `SYMOPT_DEFERRED_LOADS`, `SYMOPT_LOAD_LINES`, `SYMOPT_FAIL_CRITICAL_ERRORS`, `SYMOPT_NO_PROMPTS`, `SYMOPT_INCLUDE_32BIT_MODULES`, and `SYMOPT_AUTO_PUBLICS` flags before initializing the symbol handler. These additional flags:
- Prevent error dialogs during crash handling
- Disable interactive prompts  
- Include 32-bit modules in 64-bit process enumeration
- Automatically search public symbol tables when private symbols aren't available

The symbol handler is initialized with a comprehensive search path that includes both the executable directory and the current working directory, ensuring PDB files (MSVC) or DWARF symbols (MinGW) are found regardless of where the application is run from.

The crash handler uses `SymInitialize` with automatic module enumeration (third parameter set to `TRUE`), which automatically loads symbols for all currently loaded modules (including the main executable, Qt libraries, and other DLLs). This ensures that stack traces show function names from both the application code and all loaded libraries.

### Crypto++ Library Compatibility

The application uses the Crypto++ encryption library which has a debug assertion system (`CRYPTOPP_ASSERT`). By default, when debug symbols are enabled, Crypto++ automatically enables `CRYPTOPP_DEBUG`, which causes `CRYPTOPP_ASSERT` to raise `SIGTRAP` on Unix-like systems or call `DebugBreak()` on Windows. This can interfere with our crash log handler.

To prevent this interference while still maintaining debug symbols for our own crash logging:

- `CRYPTOPP_DEBUG` is explicitly disabled by defining `CRYPTOPP_DEBUG=0` in CMakeLists.txt
- A `SIGTRAP` handler is installed on Unix-like systems to catch any trap signals that may still occur
- This ensures that our crash log handler takes precedence and can properly capture stack traces

This configuration allows us to have debug symbols for meaningful crash logs without triggering Crypto++'s assertion system that could mask the real cause of crashes.

### Async-Signal-Safety

The signal handlers (`signalHandler` and `windowsExceptionHandler`) are implemented using only **async-signal-safe** functions to prevent secondary crashes when handling the original crash. This means:

- No Qt functions (QString, QFile, etc.) are called from within signal handlers
- Only low-level system calls (write, open, close on Unix; _write, _open, _close on Windows) are used
- Stack traces use `backtrace()` and `backtrace_symbols_fd()` on Unix (both are async-signal-safe per POSIX)
- Stack traces use `CaptureStackBackTrace()` and `SymFromAddr()` on Windows (safe to call from exception handlers)
- No dynamic memory allocation occurs in the signal handlers (except what backtrace_symbols_fd uses internally, which is safe)
- String operations use only static, pre-allocated buffers
- On Windows, `_write` is used directly (instead of `WriteFile`) to avoid text encoding conversions that could produce garbled output

This design ensures that even if the application is in a severely corrupted state when a crash occurs, the crash handler can still safely write diagnostic information including stack traces to help identify the problem.

### Text Encoding

To ensure crash logs are readable on all platforms, the application explicitly sets UTF-8 encoding for all text log files:

- The `generateCrashLog()` function uses `QTextStream::setEncoding(QStringConverter::Utf8)` to ensure crash logs are written in UTF-8
- The `logMessage()` function also explicitly sets UTF-8 encoding for application logs
- Both functions call `setGenerateByteOrderMark(false)` to explicitly disable BOM generation, ensuring clean UTF-8 output without byte order marks
- Files are opened **without** the `QIODevice::Text` flag to avoid conflicts with QTextStream's encoding. When using QTextStream with explicit encoding, the `QIODevice::Text` flag should not be used as it can interfere with the stream's encoding behavior
- On Windows, stdout and stderr are set to binary mode early in `CrashLog::install()` to prevent any text mode conversions throughout the application's lifetime
- On Windows, file descriptors are opened with `_O_BINARY` mode in signal handlers to prevent text mode conversions
- The `safeWrite()` function also defensively sets binary mode on file descriptors before writing
- This ensures that crash logs remain readable and are not corrupted by UTF-16LE encoding on Windows

Without explicit UTF-8 encoding and proper file opening mode, QTextStream on Windows may default to UTF-16LE, and stderr/stdout may perform text mode conversions, which causes log files to appear garbled when opened with standard text editors or read as ASCII/UTF-8. The combination of `QIODevice::Text` flag and explicit encoding can also cause conflicts, so files should be opened without text mode when using QTextStream with explicit encoding.

## Platform Support

The crash handler supports:
- **Windows**: Catches Windows-specific exceptions using SetUnhandledExceptionFilter. Stack traces show function names with offsets and addresses.
- **Linux/Unix**: Catches POSIX signals including SIGSEGV, SIGABRT, SIGFPE, SIGILL, SIGBUS, SIGTRAP. Stack traces show symbol names and addresses.
- **macOS**: Catches POSIX signals including SIGSEGV, SIGABRT, SIGFPE, SIGILL, SIGBUS, SIGTRAP. Stack traces show symbol names and addresses.

## Usage

The crash handler is automatically installed when the application starts. No additional configuration is required. In case of a crash:

1. The crash handler catches the signal/exception
2. A crash message is immediately printed to stderr
3. A crash log with stack trace is written to `crash.log` in the current directory
4. The application terminates

### Example Crash Log

On Unix/Linux/macOS systems, the crash log will look like:

```
=== CRASH LOG ===

Crash Reason: Segmentation Fault (SIGSEGV)

Application: Usagi-dono
Version: 1.0.0
Timestamp: 2025-01-15 14:30:22

Qt Version: 6.4.2
OS: Ubuntu 24.04 LTS
Kernel Type: linux
Kernel Version: 6.8.0-49-generic
Product Type: ubuntu
Product Version: 24.04
CPU Architecture: x86_64
Build CPU Architecture: x86_64
CPU Cores: 8
Total Physical Memory: 16384 MB

Display Information:
  Screen 1: 1920x1080 @ 96.0 DPI

Stack Trace:
./usagi(+0x1234)[0x5555555551234]
./usagi(+0x5678)[0x5555555555678]
/lib/x86_64-linux-gnu/libc.so.6(+0x45330)[0x7f1234545330]
...

=== END OF CRASH LOG ===
```

On Windows systems, the crash log will show function names with offsets:

```
=== CRASH LOG ===

Crash Reason: Access Violation

Application: Usagi-dono
Version: 1.0.0
Timestamp: 2025-01-15 14:30:22

Qt Version: 6.4.2
OS: Windows 11 (10.0)
Kernel Type: winnt
Kernel Version: 10.0.22621
Product Type: windows
Product Version: 11
CPU Architecture: x86_64
Build CPU Architecture: x86_64
CPU Cores: 12
Total Physical Memory: 32768 MB
Available Physical Memory: 16384 MB

Display Information:
  Screen 1: 2560x1440 @ 96.0 DPI
  Screen 2: 1920x1080 @ 96.0 DPI

Stack Trace:
  [0] MainWindow::onButtonClick + 0x000000000000001a
  [1] QWidget::event + 0x0000000000000123
  [2] QApplicationPrivate::notify_helper + 0x000000000000004f
...

=== END OF CRASH LOG ===
```

## Testing

The crash log functionality is thoroughly tested in `tests/test_crashlog.cpp`:

- **UTF-8 Encoding Tests**: Verify that log files and crash logs are written with proper UTF-8 encoding (without BOM) and not misinterpreted as UTF-16.
- **Complete Process Tests**: Test the full crash log generation workflow including data type conversions (QString → QTextStream → file).
- **Null Byte Tests**: Ensure crash log files don't contain extra null bytes that would cause text editors to misinterpret the encoding.
- **Stack Trace Function Name Resolution Test**: Verify that stack traces contain function names where possible. While not all frames will have names (system libraries may lack debug symbols), this test ensures that at least some frames have resolved function names, helping catch symbol resolution issues.

To run the tests:

```bash
cd build
cmake ..
make test_crashlog
QT_QPA_PLATFORM=offscreen ./tests/test_crashlog
```

The stack trace test (`testStackTraceHasFunctionNames`) specifically addresses the issue where some stack frames showed only memory addresses without function names. The test:
- Verifies at least one frame has a resolved function name
- Reports the percentage of frames with names for diagnostics
- Provides warnings if less than 20% have names (indicating potential configuration issues)
- Acknowledges that external libraries without debug symbols won't have names

## Troubleshooting Missing Function Names

If crash logs show only memory addresses without function names from the Usagi codebase (but Qt library functions appear), this usually indicates a symbol resolution problem:

### MSVC Builds
- **Problem**: PDB file is missing or not in the symbol search path
- **Solution**: Ensure the `.pdb` file generated during compilation is in the same directory as the executable
- **Verification**: After building, check that both `usagi.exe` and `usagi.pdb` exist in the same directory
- **Build Configuration**: Use `/Zi` (debug info) and `/DEBUG:FULL` (complete symbols) as configured in CMakeLists.txt

### MinGW/GCC Builds on Windows
- **Problem**: Debug symbols were stripped from the executable, or DWARF symbols are not being read correctly by DbgHelp
- **Additional Issue**: Function names may appear **mangled** (e.g., `_ZN10QTableView11qt_metacallE...`) instead of readable names like `QTableView::qt_metacall()`. This is because MinGW uses Itanium C++ ABI name mangling, which Windows DbgHelp.dll does not automatically demangle (it only demangles MSVC-style decorations).
- **Solution**: 
  - Ensure `-g` flag is used during compilation (already configured in CMakeLists.txt)
  - Do not use strip tools on the executable after building
  - For best results on Windows, use MSVC rather than MinGW for builds that need crash log symbol resolution
  - **Optional**: Use the `c++filt` utility to demangle names: `c++filt _ZN10QTableView11qt_metacallE...` will output `QTableView::qt_metacall(...)`
- **Note**: MinGW uses DWARF debug format embedded in the executable, while Windows DbgHelp.dll primarily supports PDB files. Symbol resolution may be limited or show mangled C++ names.

### Demangling C++ Names from MinGW Crash Logs
If your crash log shows mangled names like `_ZN10QTableView11qt_metacallEN11QMetaObject4CallEiPPv`, you can demangle them manually:

1. **Using c++filt** (included with MinGW):
   ```bash
   echo "_ZN10QTableView11qt_metacallEN11QMetaObject4CallEiPPv" | c++filt
   # Output: QTableView::qt_metacall(QMetaObject::Call, int, void**)
   ```

2. **Using online demanglers**: Search for "C++ name demangler" and paste the mangled name

This is only necessary for MinGW builds. MSVC builds automatically show demangled names.

### Verifying Symbol Resolution
After building, you can verify symbol information:
- **MSVC**: Check that the PDB file exists alongside the executable
- **MinGW**: Use `nm usagi.exe | grep "function_name"` to verify symbols are present
- The crash log will now include diagnostic information showing how many symbols were resolved

### Example Diagnostic Output
The crash log now includes symbol resolution statistics:
```
Symbol search path: C:\path\to\executable;C:\current\directory
...
[stack trace]
...
Symbol resolution: 15 of 30 frames resolved
Note: Few symbols resolved. Check if PDB file exists alongside executable.
```

If no symbols are resolved, the crash log will indicate possible causes.

Possible future improvements:
- Include more system information (memory usage, CPU info)
- Write crash logs to timestamped files in the application data directory
- Add a crash report dialog allowing users to submit crash reports
- Compress old crash logs automatically
- Add crash log viewer in the application UI
- Use core dump analysis tools for detailed diagnostics
